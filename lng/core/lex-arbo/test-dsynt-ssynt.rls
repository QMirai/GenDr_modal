
/*3 configurations for "split" attribute (X and Y correspond to the same LS node):
(1) Determines: RS: ?X-det-> ?Y{split=bottom}
(2) Governed Preps: RS: ?X{split=top}-prepos-> ?Y{split=root}
(3) Polylex Units: RS: ?X{split=top}-?r-> ?Y{split=bottom}

=>
- if a node contains split=bottom, this node cannot govern or receive any relation.*/
DSynt1<=>SSynt abstract core : rule
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
DSynt<=>SSynt abstract lng : rule
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt abstract quantification : rule
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt lex_class : core
[
  leftside = [
?Xl{}
  ]
  conditions = [
?Xl.class;
not lexicon::(?Xl.dlex).dpos; // exclude words that have an entry in the lexicon
  ]
  rightside = [
?Xr{
  <=> ?Xl
  slex=?Xl.dlex
  spos=lexicon::(?Xl.class).spos
}
  ]
  correspondence = [

  ]
]
/*If the noun has no other dependent than the determiner.*/
DSynt1<=>SSynt lex_det : core
[
  leftside = [
?Xl{
  dpos=N
}
?L <- semanticon::(?Xl.definiteness).(lex)
  ]
  conditions = [
?Xl.definiteness;
?Xr.dpos=N;
not ?Xr.spos=proper_noun;
not ?Xr.spos=pronoun;
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  det-> ?Yr{
    slex=?L
    dlex=?L
    dpos=lexicon::(?L).dpos
    spos=lexicon::(?L).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt abstract lex_idiom : core
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Simple lexicalization*/
DSynt1<=>SSynt lex_lu : core
[
  leftside = [
l:?Xl
  ]
  conditions = [
not lf::(?Xl.dlex).dpos;  // ?Xl is not a syntagmatic LF (all LFs have a dpos in "lf")
lexicon::(?Xl.dlex).dpos; // This lexical unit is in the lexicon
not lexicon::(?Xl.dlex).idiom;
not ?Xl.dlex=PRO;
  ]
  rightside = [
?Xr {
  <=> ?Xl
  slex=?Xl.dlex
  dlex=?Xl.dlex
  dpos=lexicon::(?Xl.dlex).dpos
  spos=lexicon::(?Xl.dlex).spos
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt synt_APPEND_name : core
[
  leftside = [
?Xl{
  l:APPEND-> ?Yl{}
}
  ]
  conditions = [
?Yr.spos=proper_noun;
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  name-> rc:?Yr{ rc:<=> ?Yl }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt synt_ATTR : core
[
  leftside = [
?Xl{
  l:ATTR-> ?Yl{}
}
  ]
  conditions = [
not ?Xr.split=bottom;
not ?Xr.spos=auxiliary;
//not ?Yr.spos=determiner;
not ?Yr.spos=number;
// FIXME: constrain dpos combinations: V-->Adv, N-->Adj, etc.,
//(?Xr.dpos=N and ?Yr.dpos=Adj) or ((not ?Xr.dpos=N) and ?Yr.dpos=Adv);
// This doesn't always work.
?Yr.ssynt=OK;  // Wait for full lexicalization
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  modif-> rc:?Yr{ rc:<=> ?Yl }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt synt_COORD : core
[
  leftside = [
?Xl{
  l:COORD-> ?Yl{}
}
  ]
  conditions = [
?Yr.ssynt=OK;  // Wait for full lexicalization
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  coord-> rc:?Yr{ rc:<=> ?Yl }
}
  ]
  correspondence = [

  ]
]
/*Handles actants that don't require a governed Prep, Conj, etc.*/
DSynt1<=>SSynt synt_actant_dir : core
[
  leftside = [
?Xl{
  l:?r-> ?Yl{}
}
?GP <- lexicon::(?Xr.slex).(gp).(?r)
  ]
  conditions = [
?GP.rel;        // Check that the GP specifies the SSyntRel
(not ?GP.prep) or ?GP.prep="";	// There is no governed Prep
?GP.dpos=?Yr.dpos or (not ?GP.dpos);
not ?GP.rel=subj;  // Subject is handled by other rules
?Yr.ssynt=OK;  // Wait for full lexicalization
not ?Yr.auxdep;        // Attach on the top Aux
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  ?GP.rel-> rc:?Yr{
      rc:<=> ?Yl
      case=?GP.case
  }
}
  ]
  correspondence = [

  ]
]
/*Creates the edges of all actants -except SSynt subject- introduced by a purely syntactic
 connector such as prep or conjunction (doesn't apply to semantic prepositions/conjunctions).*/
DSynt1<=>SSynt synt_actant_prep : core
[
  leftside = [
?Xl{
  l:?r-> ?Yl{}
}
?GP <- lexicon::(?Xr.slex).(gp).(?r)
  ]
  conditions = [
?GP.rel;           // Check that the GP specifies the SSyntRel
?GP.prep and (not ?GP.prep="");	   // There is a governed Prep
?GP.dpos=?Yl.dpos or (not ?GP.dpos);
not ?GP.rel=subj;  // Subject is handled by other rules
?Yr.ssynt=OK;  // Wait for full lexicalization
not ?Yr.auxdep;        // Attach on the top Aux
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  ?GP.rel-> ?Zr{
    <=> ?Yl
    slex=?GP.prep
    dpos=lexicon::(?GP.prep).dpos
    spos=lexicon::(?GP.prep).spos
    split=top
    lexicon::(?GP.prep).(gp).(II).(rel)-> rc:?Yr{
      <=> rc:?Yl
      case=lexicon::(?GP.prep).(gp).(II).(case)
      split=bottom
    }
  }
}
  ]
  correspondence = [

  ]
]
/*Handles actants that don't require a governed Prep, Conj, etc.

FIXME: subject raising for Aux*/
DSynt1<=>SSynt synt_subj_dir : core
[
  leftside = [
?Xl{
  l:?r-> ?Yl{}
}
?GP <- lexicon::(?Xr.slex).(gp).(?r)
  ]
  conditions = [
?GP.rel=subj;    // This rule handles subjects only
?Xl.finiteness=FIN;    // Only finite verbs have a subject
not ?GP.prep;	       // There is no governed Prep
not ?Xr.split=bottom;  // ?Xr is not the bottom part of a split node
not ?Xr.auxdep;        // Attach on the top Aux
?Xr.ssynt=OK;          // Wait for full lexicalization
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  subj-> rc:?Yr{ rc:<=> ?Yl
      case=?GP.case
  }
}
  ]
  correspondence = [

  ]
]
/*Those rules are language specific. Keep them apart in case we have to develop multilingual grammars.*/
DSynt1<=>SSynt abstract DEV : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=DEV;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt abstract ENG : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=ENG;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt abstract FRE : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=FRE;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for Lithuanian rules.*/
DSynt<=>SSynt abstract LIT : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=LIT;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for Persian rules.*/
DSynt<=>SSynt abstract PER : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=PER;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*See synt_ATTR_quant rule*/
DSynt1<=>SSynt synt_numerative : quantification
[
  leftside = [
?Xl{
  l:ATTR-> ?Yl{}
}
  ]
  conditions = [
?Yl.dpos=Num;
  ]
  rightside = [
rc:?Xr{ <=> ?Xl
  num-> rc:?Yr{ <=> ?Yl }
}
  ]
  correspondence = [

  ]
]
DSynt<=>SSynt lex_idiom_w1_w2 : lex_idiom
[
  leftside = [
l:?Xl
  ]
  conditions = [
lexicon::(?Xl.dlex).idiom.type=w1_w2;
  ]
  rightside = [
?W1 {
  <=> ?Xl
  dlex=?Xl.dlex  
  slex=lexicon::(?Xl.dlex).idiom.w1
  dpos=lexicon::(?Xl.dlex).dpos
  spos=lexicon::(?Xl.dlex).spos
  lexicon::(?Xl.dlex).idiom.r1-> ?w2 {
    slex=lexicon::(?Xl.dlex).idiom.w2
    dpos=lexicon::(lexicon::(?Xl.dlex).idiom.w2).dpos
    spos=lexicon::(lexicon::(?Xl.dlex).idiom.w2).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt<=>SSynt lex_idiom_w1_w2_w3 : lex_idiom
[
  leftside = [
l:?Xl
  ]
  conditions = [
lexicon::(?Xl.dlex).idiom.type=w1_w2_w3;
  ]
  rightside = [
?W1 {
  <=> ?Xl
  dlex=?Xl.dlex  
  slex=lexicon::(?Xl.dlex).idiom.w1
  dpos=lexicon::(?Xl.dlex).dpos
  spos=lexicon::(?Xl.dlex).spos
  lexicon::(?Xl.dlex).idiom.r1-> ?w2 {
    slex=lexicon::(?Xl.dlex).idiom.w2
    dpos=lexicon::(lexicon::(?Xl.dlex).idiom.w2).dpos
    spos=lexicon::(lexicon::(?Xl.dlex).idiom.w2).spos
    ssynt=OK
  }
  lexicon::(?Xl.dlex).idiom.r2-> ?w3 {
    slex=lexicon::(?Xl.dlex).idiom.w3
    dpos=lexicon::(lexicon::(?Xl.dlex).idiom.w3).dpos
    spos=lexicon::(lexicon::(?Xl.dlex).idiom.w3).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSyn DEV_aux_past : DEV
[
  leftside = [
?Xl{
  dpos=V
  tense=PAST
}
  ]
  conditions = [
not ?Xr.split=bottom;
  ]
  rightside = [
?Yr{ <=> ?Xl
  slex=avoir_2
  dlex=avoir_2
  dpos=lexicon::(avoir_2).dpos
  spos=lexicon::(avoir_2).spos
  finiteness=?Xl.finiteness
  ssynt=OK
  aux-> rc:?Xr{
    <=> ?Xl
    finiteness=PART
    gender=MASC
    number=SG
    auxdep=yes
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSyntn DEV_det_def : DEV
[
  leftside = [
?Xl{
  dpos=N
  definiteness=DEF
}
  ]
  conditions = [
not ?Xr.split=bottom;
?Xr.dpos=N;
not ?Xr.spos=proper_noun;
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  det-> ?Yr{
    slex=le
    dlex=le
    dpos=lexicon::(le).dpos
    spos=lexicon::(le).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt DEV_ssynt_ok : DEV
[
  leftside = [
?Xl{}
  ]
  conditions = [
not (?Xl.dpos=V and ?Xl.tense=PAST);
not ?Xr.ssynt;
  ]
  rightside = [
rc:?Xr{ <=> ?Xl
  ssynt=OK
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt det_def : ENG
[
  leftside = [
?Xl{
  dpos=N
  definiteness=DEF
}
  ]
  conditions = [
?Xr.dpos=N;
not ?Xr.split=bottom;
not ?Xr.spos=proper_noun;
not ?Xr.spos=pronoun;
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  det-> ?Yr{
    slex=the
    dlex=the
    dpos=lexicon::(the).dpos
    spos=lexicon::(the).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt det_indef : ENG
[
  leftside = [
?Xl{
  dpos=N
  definiteness=INDEF
}
  ]
  conditions = [
?Xr.dpos=N;
not ?Xr.split=bottom;
not ?Xr.spos=proper_noun;
not ?Xr.spos=pronoun;
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  det-> ?Yr{
    slex=a
    dlex=a
    dpos=lexicon::(a).dpos
    spos=lexicon::(a).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt lex_aux_no : ENG
[
  leftside = [
?Xl
  ]
  conditions = [
not (?Xl.dpos=V and ?Xl.finiteness=FIN and ?Xl.mood=IND and ?Xl.perfect=yes);
  ]
  rightside = [
rc:?Xr{
  rc:<=>?Xl
  ssynt=OK
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt lex_aux_no : FRE
[
  leftside = [
?Xl
  ]
  conditions = [
not (?Xl.dpos=V and ?Xl.finiteness=FIN and ?Xl.mood=IND and ?Xl.tense=PAST);
  ]
  rightside = [
rc:?Xr{
  rc:<=>?Xl
  ssynt=OK
}
  ]
  correspondence = [

  ]
]
DSynt1<=>SSynt lex_aux_past_subj : FRE
[
  leftside = [
?Xl{
  dpos=V
  tense=PAST
  l:?r-> ?Yl{}
}
?GP <- lexicon::(?Xl.dlex).(gp).(?r)
  ]
  conditions = [
?GP.rel=subj;        // This rule handles subjects only
?Xl.finiteness=FIN;  // Only finite verbs have a subject
?Xl.mood=IND;        // Only indicative verbs are inflected
?Yr.ssynt=OK;        // Wait for subject's full lexicalization
  ]
  rightside = [
?Zr{ <=> ?Xl
  slex=lexicon::(?Xl.dlex).(auxiliary)
  dlex=lexicon::(?Xl.dlex).(auxiliary)
  dpos=lexicon::(lexicon::(?Xl.dlex).(auxiliary)).dpos
  spos=lexicon::(lexicon::(?Xl.dlex).(auxiliary)).spos
  finiteness=?Xl.finiteness
  mood=?Xl.mood
  ssynt=OK
  subj-> rc:?Yr{ rc:<=> ?Yl
    case=?GP.case
  }
  aux-> rc:?Xr{
    rc:<=> ?Xl
    finiteness=PART
    gender=MASC
    number=SG
    auxdep=yes
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt<=>SSynt aux_det_indef : PER
[
  leftside = [
?Xl{
  dpos=N
  definiteness=INDEF
}
  ]
  conditions = [
not ?Xr.split=bottom;
?Xr.dpos=N;
not ?Xr.spos=proper_noun;
  ]
  rightside = [
rc:?Xr{ rc:<=> ?Xl
  det-> ?Yr{
    slex=i
    dlex=i
    dpos=lexicon::(i).dpos
    spos=lexicon::(i).spos
    ssynt=OK
  }
}
  ]
  correspondence = [

  ]
]
DSynt<=>SSynt aux_fut : PER
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]