
Sem<=>DSynt abstract core : rule
[
  leftside = [
// Input graph (semantic representation)
  ]
  conditions = [
// Conditions for the application of the rule
  ]
  rightside = [
// Output graph (deep syntactic representation)
  ]
  correspondence = [

  ]
]
/*This package handles collocations with lexical functions. For details, see:
Florie Lambrey, 2016, Implémentation des collocations pour la
réalisation de texte multilingue, M.A. thesis, Université de montréal.

Having default values in abstract classes (for example, a default Oper1
for all nouns) may cause duplicate output structures, especially for
support verbs. Avoid it in your lexicon.

FIXME: dpos constraints are missing on the actant's node.
       See solution in lex_Vsupp_i : spread to all LFs with actants.*/
Sem<=>DSynt abstract lf : rule
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Language-specific rules go in this package.*/
Sem<=>DSynt abstract lng : rule
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract grammemes : core
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract lexical : core
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*The rules in this package pick a root for the DSyntR.

The root of the tree is usually the most communicatively
sallient node. It is marked with the "main" relation (from
the S bubble).

Typically, the root should be a finite verb. Some languages
allow other parts of speech in that position. Even in verbal
root languages, non-verbal sentences do occur (headlines,
etc.).*/
Sem<=>DSynt abstract root : core
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract syntactic : core
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract adjectival_derivation : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract modifier : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*FIXME: these rules generate lots of structures. Check.*/
Sem<=>DSynt abstract no_patterns : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract nominal_governor : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract preposition_case : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract realisation_verbs : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt abstract semantic_verbs : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*FIXME: Lots of duplicates are generated when there is a default value for the LF in the lexicon's lexical class entry.

FIXME: dpos constraints are missing on the actant's node. Then lexicalization is not constrained and the node has no dpos.
       See solution in lex_Vsupp_i : spread to all LFs with actants.*/
Sem<=>DSynt abstract support_verbs : lf
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for testing and development rules.*/
Sem<=>DSynt abstract DEV : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=DEV;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for English-specific rules.*/
Sem<=>DSynt abstract ENG : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=ENG;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for French-specific rules.*/
Sem<=>DSynt abstract FRE : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=FRE;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for Lithuanian-specific rules.*/
Sem<=>DSynt abstract LIT : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=LIT;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*Package for Persian-specific rules.*/
Sem<=>DSynt abstract PER : lng
[
  leftside = [

  ]
  conditions = [
lexicon::(META).lng.iso=PER;
  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*FIXME: doesn't work with fre/str/journal_economie.str MANUFACTURE*/
Sem<=>DSynt defaults_N_definiteness : grammemes
[
  leftside = [
?Xl {}
  ]
  conditions = [
?Xr.dpos=N;
not ?Xl.definiteness;
not ?Xr.definiteness;
?Xr.dsynt=OK;
  ]
  rightside = [
rc:?Xr {
  rc:<=> ?Xl
  definiteness=lexicon::(META).(defaults).(?Xr.dpos).(definiteness)
}
  ]
  correspondence = [

  ]
]
/*FIXME: doesn't work with fre/str/journal_economie.str MANUFACTURE*/
Sem<=>DSynt defaults_N_number : grammemes
[
  leftside = [
?Xl {}
  ]
  conditions = [
?Xr.dpos=N;
not ?Xl.number;
not ?Xr.number;
?Xr.dsynt=OK;
  ]
  rightside = [
rc:?Xr {
  rc:<=> ?Xl
  number=lexicon::(META).(defaults).(?Xr.dpos).(number)
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt defaults_V_mood : grammemes
[
  leftside = [
?Xl {}
  ]
  conditions = [
?Xr.dpos=V;
not ?Xl.mood;
not ?Xr.mood;
?Xr.dsynt=OK;
  ]
  rightside = [
rc:?Xr {
  rc:<=> ?Xl
  mood=lexicon::(META).(defaults).(?Xr.dpos).(mood)
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt defaults_V_tense : grammemes
[
  leftside = [
?Xl {}
  ]
  conditions = [
?Xr.dpos=V;
not ?Xl.tense;
not ?Xr.tense;
?Xr.dsynt=OK;
  ]
  rightside = [
rc:?Xr {
  rc:<=> ?Xl
  tense=lexicon::(META).(defaults).(?Xr.dpos).(tense)
}
  ]
  correspondence = [

  ]
]
/*When we had to guess the lexicalization, a node might not have received
a dpos attribute. This rule checks that it has this attribute and
changes the dsynt status to OK.
The class attribute will be used by rule rel_actant_guess.*/
Sem<=>DSynt check_dpos_gp : lexical
[
  leftside = [
?Xl
  ]
  conditions = [
not ?Xl.class;
not ?Xr.dsynt=OK;
?Xr.check_dpos;
?Xr.dpos;
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dsynt=OK
  warning=?Xr.warning+"Got DPOS from governor's GP. "
  class="DPOS_"+?Xr.dpos
}
  ]
  correspondence = [

  ]
]
/*When we had to guess the lexicalization, a node might not have received
a dpos attribute. In last resort, if the node didn't receive a dpos,
we guess it's probably a noun.
The class attribute will be used by rule rel_actant_guess.*/
Sem<=>DSynt check_dpos_guess : lexical
[
  leftside = [
?Xl
  ]
  conditions = [
not ?Xl.class;
not ?Xr.dsynt=OK;
?Xr.check_dpos;
not ?Xr.dpos;
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dsynt=OK
  dpos=N
  warning=?Xr.warning+"Guessed dpos. "
  class="DPOS_N"
}
  ]
  correspondence = [

  ]
]
/*This rule bypasses standard lexicalization for special semantemes such
as numbers, named entities, etc. These semantemes must have an attribute
"class" that gives their lexical class. The class must be defined in the
lexicon, where default attributes may be retrieved (in particular, dpos).

This rule is bypassed if there is an entry in the semanticon.*/
Sem<=>DSynt lex_class : lexical
[
  leftside = [
l:?Xl{}
  ]
  conditions = [
not ?Xr.dsynt=OK;               // ?Xr is not lexicalized yet.
not semanticon::(?Xl.sem).lex;  // Ignore rule if lex is defined in semanticon
?Xl.class;                      // This attribute signals a special semanteme
lexicon::(?Xl.class).(dpos);    // The class must be defined in lexicon
//(not ?Xr.dpos) or ?Xr.dpos=lexicon::(?Xl.class).(dpos);
                                // if ?Xr has a dpos restriction,
                                // it must match that of the lexical class
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dlex=?Xl.sem
  dpos=lexicon::(?Xl.class).(dpos)
  dsynt=OK
}
  ]
  correspondence = [

  ]
]
/*If the semanteme is not in the semanticon but there is an entry with
the same label in the lexicon, assume the lexicalization is trivial.
This rule must be kept in Sync with lex_standard.*/
Sem<=>DSynt lex_guess_from_lexicon : lexical
[
  leftside = [
l:?Xl{}
  ]
  conditions = [
not ?Xr.dsynt=OK;               // not already lexicalized
not ?Xl.class;                  // not a special semanteme (hour, etc.)
not semanticon::(?Xl.sem).lex;  // not in the semanticon
not lf::(?Xl.sem).dpos;         // not a LF
lexicon::(?Xl.sem).dpos;        // exists in the lexicon
(not ?Xr.dpos) or ?Xr.dpos=lexicon::(?Xl.sem).(dpos);
                                // if ?Xr has a dpos restriction,
                                // it must match that of the lexical entry
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dlex=?Xl.sem
  dpos=lexicon::(?Xl.sem).(dpos)
  dsynt=OK
  warning=?Xr.warning+"Not in the semanticon. "
}
  ]
  correspondence = [

  ]
]
/*If the semanteme has a lexicalization in the semanticon but the
corresponding lexeme is not in the lexicon, this rule flags the
node with a warning.
The dpos attribute might be missing so we don't give the node
the dsynt=OK status yet. The check_dpos rules will make sure that
a dpos has been assigned.
This rule must be kept in Sync with lex_standard.*/
Sem<=>DSynt lex_guess_from_semanticon : lexical
[
  leftside = [
l:?Xl{}
?L <- semanticon::(?Xl.sem).(lex)
  ]
  conditions = [
not ?Xl.class;
semanticon::(?Xl.sem).lex;
not lexicon::(?L).dpos;
not lf::(?L).dpos;
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dlex=?L
  check_dpos=yes
  warning=?Xr.warning+"Not in the lexicon. "
}
  ]
  correspondence = [

  ]
]
/*If all other lexicalization rules fail, this one transfers the Sem node's label to the DSynt node.*/
Sem<=>DSynt lex_guess_unknown : lexical
[
  leftside = [
l:?Xl{}
  ]
  conditions = [
not ?Xl.class;                 // not a special semanteme (hour, etc.)
not semanticon::(?Xl.sem).lex; // not in the semanticon
not lexicon::(?Xl.sem).dpos;   // not in the lexicon
not lf::(?Xl.sem).sem;         // not a semantic LF
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dlex=?Xl.sem
  check_dpos=yes
  warning=?Xr.warning+"Unknown word. "
}
  ]
  correspondence = [

  ]
]
/*Simple lexicalization rule.
Changes made in this rule must be made also in lex_warning_lexicon.
The DSynt node already exists but has not been lexicalized. It has been created by synt_root or an actancial rule.
This rule assigns a lexeme to the existing DSynt node.
It retrieves the lexicalization from the semanticon.
It picks a lexical unit that matches DPOS contraints if any.
This rule consumes the Sem node.
Don't apply to special meanings (canned text, hour, number, etc.).

On a un noeud ?Xl qu'on va locker (on le rend non disponible pour d'autres règles)
On définit ?L. 

semanticon:: -> va dans le semanticon
(?Xl.sem) -> cherche l'entrée qui correspond au sem du noeud ?Xl (ex. dormir)
(lex) -> récupère l;a valeur de l'attribut lex de cette entrée*/
Sem<=>DSynt lex_standard : lexical
[
  leftside = [
l:?Xl{}
?L <- semanticon::(?Xl.sem).(lex)
  ]
  conditions = [
semanticon::(?Xl.sem).lex;  // ?Xl has a lexicalization
lexicon::(?L).dpos;         // the lexicalization exists in the lexicon
not ?Xr.dsynt=OK;           // ?Xr must not be already lexicalized
(not ?Xr.dpos) or (?Xr.dpos="") or ?Xr.dpos=lexicon::(?L).(dpos);
                            // if ?Xr has a dpos restriction,
                            // it must match that of the lexical entry
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  dlex=?L
  dpos=lexicon::(?L).(dpos)
  dsynt=OK
}
  ]
  correspondence = [

  ]
]
/*This rule builds the standard root of the DSynt tree. The best         
candidate for that is the node realizing the main semanteme         
of the Rheme.*/
Sem<=>DSynt root_standard : root
[
  leftside = [
// The most sallient semanteme
// of the sentence is marked with
// the "main" relation
?S{
  sem=S		
  main-> ?Xl	
}
  ]
  conditions = [

  ]
  rightside = [
// The syntactic root is a finite verb
?Xr {
  <=> ?Xl
  clause=main
  dpos=V
  finiteness=FIN
}
  ]
  correspondence = [

  ]
]
/*This rule was added and not replacing the previous one 
 because for some entries the ?L variable cannot be taken into account
(Ex: "perder" in At.Madrid-Athletic (At.Mad)).
THIS RULE CREATES A DECREASE OF THE GENERATION SPEED because it overlaps a lot with the previous one (because of the lock, the number of output str is doubled).
THERE SEEMS TO BE A BIG BUG IN MATE: COPY THIS RULE, REMOVE CONDITIONS AND LINES WITH "R"s, AND SEE THAT
 THE RESULT IS DIFFERENT IF THE LINE ?R <- lexicon::(?Xr.dlex).(gp).(?r) IS COMMENTED OR NOT!
 Is it due to the fact that ?Yl is or not in the semanticon?
 Problem possibly set with rule NOsem.

Comment about the no_switch_1 condition: see Con-Sem mark_no_switch;
The node in the conceptual structure which caused that ?Yl bears this attribute could be realized as another lexeme!!
If this lexeme has the usual mapping 1=ATTR, this rule synt_actant_lex should apply!
Second part of the condition: if the governor is the node which caused that ?Yl bears this attribute, synt_actant_lex should apply.

lexicon:: -> va dans lexicon
(?Xr.dlex) -> l'entrée qui correspond à la valeur du trait dlex du noeud ?Xr (en syntaxe)
(gp) -> va dans son gp
(?r) -> récupère l'équivalent de la relation ?r en syntaxe profonde (ex. I)

?R-> ?Yr = on créé une relation ?R entre ?Xr et ?Yr et on créé en même temps le noeud ?Yr.*/
Sem<=>DSynt actant_gp : syntactic
[
  leftside = [
?Xl{
  l:?r-> ?Yl{}
}
?R <- lexicon::(?Xr.dlex).(gp).(?r)
  ]
  conditions = [
not ?Xr.lf;				// Xr is not a LF
not ?R="---";				// the realisation of ?R must not be blocked
?Xr.dsynt=OK and not ?Xr.split=top; 	// not sure if always has to be the case.
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  ?R-> ?Yr{
      <=> ?Yl
      dpos=lexicon::(?Xr.dlex).(gp).(?R).(dpos)
      finiteness=lexicon::(?Xr.dlex).(gp).(?R).(finiteness)
      mood=lexicon::(?Xr.dlex).(gp).(?R).(mood)
      subject=lexicon::(?Xr.dlex).(gp).(?R).(subject)
      det=lexicon::(?Xr.dlex).(gp).(?R).(det)
      definiteness=lexicon::(?Xr.dlex).(gp).(?R).(definiteness)
      case=lexicon::(?Xr.dlex).(gp).(?R).(case)
      cat=lexicon::(?Yl.dlex).(cat)
  }
}
  ]
  correspondence = [

  ]
]
/*If the lexical entry has no GP for some reason (likely because we
guessed the lexicalization and it has no entry in the lexicon),
we use the GP of the class, according to the DPOS of the node.*/
Sem<=>DSynt actant_guess : syntactic
[
  leftside = [
?Xl{
  l:?r-> ?Yl{}
}
?R <- lexicon::(?Xr.class).(gp).(?r)
  ]
  conditions = [
not ?Xr.lf;				// Xr is not a LF
?Xr.dsynt=OK and not ?Xr.split=top; 	// not sure if always has to be the case
not lexicon::(?Xr.dlex).gp;             // There is no GP!
?Xr.class;                              // This comes from the lex_check_dpos rules (if guessed lexicalization) or was specified in the input (if special node)
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  warning=?Xr.warning+"Guessed GP from DPOS. "
  ?R-> ?Yr{
      <=> ?Yl
      dpos=lexicon::(?Xr.dlex).(gp).(?R).(dpos)
      finiteness=lexicon::(?Xr.dlex).(gp).(?R).(finiteness)
      mood=lexicon::(?Xr.dlex).(gp).(?R).(mood)
      subject=lexicon::(?Xr.dlex).(gp).(?R).(subject)
      det=lexicon::(?Xr.dlex).(gp).(?R).(det)
      definiteness=lexicon::(?Xr.dlex).(gp).(?R).(definiteness)
      case=lexicon::(?Xr.dlex).(gp).(?R).(case)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt anaphora : syntactic
[
  leftside = [
?Xl{  // pronoun
  l:<-> ?Yl{} // antecedent
}
  ]
  conditions = [
?Yr.dsynt=OK;
  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  antecedent=?Yr.dlex
}
rc:?Yr{
  rc:<=> ?Yl
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt append_class : syntactic
[
  leftside = [
l:?Xl{
  sem=NAME
  l:1-> ?Yl
  l:2-> l:?Zl
}
  ]
  conditions = [
not semanticon::(?Zl.sem).lex;  // Ignore rule if lex is defined in semanticon
not ?Zr.dsynt=OK;           // ?Xr is not lexicalized yet.
?Zl.class;                  // This attribute signals a special semanteme
lexicon::(?Zl.class).dpos;  // The class must be defined in lexicon
?Yr.dsynt=OK;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  APPEND-> ?Zr{
      <=> ?Zl
      dlex=?Zl.sem
      dpos=lexicon::(?Zl.class).(dpos)
      dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt attr_Num : syntactic
[
  leftside = [
l:?Xl{
  class=number
  l:?r-> ?Yl{}
}
// both belong to the same sentence:
?S*{
  sem=S
  ?Xl{}
  ?Yl{}
}
  ]
  conditions = [
?Yr.dpos=N or ?Yr.dpos=Unit;
not ?r=coref;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  ATTR-> ?Xr{
     <=> ?Xl
     dlex=?Xl.sem
     dpos=Num
     dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt attr_class : syntactic
[
  leftside = [
l:?Xl{
  l:?r-> ?Yl{}
}
  ]
  conditions = [
?Yr.dsynt=OK;
not ?Xr.dsynt=OK;
not semanticon::(?Xl.sem).lex;  // Ignore rule if lex is defined in semanticon
?Xl.class;                      // This attribute signals a special semanteme
lexicon::(?Xl.class).dpos;      // The class must be defined in lexicon
lexicon::(?Xl.class).(gp).(?r)=ATTR;
(lexicon::(?Xl.class).(dpos)=Adv and not ?Yr.dpos=N) or (?Yr.dpos=N and lexicon::(?Xl.class).(dpos)=Adj);
not ?r=coref;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  ATTR-> ?Xr{
      <=> ?Xl
      dlex=?Xl.sem
      dpos=lexicon::(?Xl.class).(dpos)
      dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt attr_lex : syntactic
[
  leftside = [
l:?Xl{
  l:?r-> ?Yl{}
}
?L <- semanticon::(?Xl.sem).(lex)
?R<-lexicon::(?L).(gp).(?r)
  ]
  conditions = [
?Yr.dsynt=OK;
not ?Xr.dsynt=OK;
semanticon::(?Xl.sem).(lex);
lexicon::(?L).(dpos);
?R=ATTR;
not (?Yr.dpos=N and lexicon::(?L).(dpos)=Adv and not lexicon::(?L).(spos)=preposition);
not (lexicon::(?L).(dpos)=Adj and not ?Yr.dpos=N);
not ?r=coref;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  ?R-> ?Xr{
      <=> ?Xl
      dlex=?L
      dpos=lexicon::(?L).(dpos)
      dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt coord_lex : syntactic
[
  leftside = [
l:?Xl{
  l:?r-> ?Yl{}
  l:?l-> ?Zl{}
}
?L <- semanticon::(?Xl.sem).(lex)
  ]
  conditions = [
semanticon::(?Xl.sem).(lex);
lexicon::(?L).(dpos);
lexicon::(?L).(gp).(?r)=COORD;
?Yr.dsynt=OK;
not ?Yr.split=bottom;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  COORD-> ?Xr{
      <=> ?Xl
      dlex=?L
      dpos=lexicon::(?L).(dpos)
      dsynt=OK
      lexicon::(?L).(gp).(?l)-> ?Zr{
	  <=> ?Zl
	  dpos=?Yr.dpos
          finiteness=?Yr.finiteness
          mood=?Yr.mood
      }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled relative_lex : syntactic
[
  leftside = [
l:?Xl{  // main predicate of the relative
  l:?r-> ?Yl{}  // noun to be modified
}
?L <- semanticon::(?Xl.sem).(lex)
  ]
  conditions = [
?Yr.dsynt=OK;
//not ?Xr.dsynt=OK;
semanticon::(?Xl.sem).(lex);
lexicon::(?L).(dpos)=V;
not ?r=coref;
  ]
  rightside = [
rc:?Yr{ // noun to modify
  rc:<=> ?Yl
  ATTR-> ?Xr{	// main predicate of the relative
      <=> ?Xl
      dlex=?L
      dpos=lexicon::(?L).(dpos)
      dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*FIXME: this rule is too generic
Applies when a semanteme is expressed as a syntactic configuration.*/
Sem<=>DSynt synt_lex : syntactic
[
  leftside = [
l:?Xl{          // 'time'
  l:1-> ?Yl{}	// verb to modify
  l:2-> l:?Tl{}	// temporal element
}
?L <-semanticon::(?Tl.sem).(lex)
?S <-semanticon::(?Xl.sem).(synt)
  ]
  conditions = [
?Yr.dpos=V; 	// ?Yr must be a verb
?Yr.dsynt=OK;	// Wait for ?Yr to be lexicalised
//lexicon::(?L).(dpos)=Adv;
  ]
  rightside = [
rc:?Yr{
  rc:<=> ?Yl
  ?S-> ?Tr{
      <=> ?Tl
	dlex=?L
	dpos=lexicon::(?L).(dpos)
	dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Ai : adjectival_derivation
[
  leftside = [
l:?Xl{			// base
  l:?r-> ?Yl {}		// rth actant modified by LF
}
?L <- semanticon::(?Xl.sem).(lex) 
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A"+?r;			// matches the sem node with the name of LF
not ( ?S 1->?Xl and (?S.sem="Anti" or 
  ?S.sem="Incep" or
  ?S.sem="Fin" or
  ?S.sem="Cont" )
);  // avoids lexicalizing Ai instead of complex LFs like AntiAi
?Yr.dpos=N;			// actant must be a noun
not ?F.merged=yes;		// The collocate must not be merged with the base
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
  ]
  rightside = [
rc:?Yr {				// rth actant
  rc:<=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{    	// LF
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{ 	// base  
      <=> ?Xl  				
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled abstract Ai_Vreal : adjectival_derivation
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled abstract Ai_Vsem : adjectival_derivation
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled abstract Ai_Vsupp : adjectival_derivation
[
  leftside = [

  ]
  conditions = [

  ]
  rightside = [

  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt disabled Ai_manner : adjectival_derivation
[
  leftside = [
l:?Xl{			// base
  l:?r-> ?Yl {}		// rth actant modified by LF
}
?L <- semanticon::(?Xl.sem).(lex) 
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A"+?r;			// matches the sem node with the name of LF
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont" );
// empêche de lexicaliser des Ai au lieu de FL complexes comme AntiAi
?Yr.dpos=N;			// actant must be a noun
not ?F.merged=yes;		// The collocate must not be merged with the base
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
  ]
  rightside = [
rc:?Yr {				// rth actant
  rc:<=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{    	// LF
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{ 	// base  
      <=> ?Xl  				
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Anti_Non_Ai : adjectival_derivation
[
  leftside = [
l:?Wl {
  sem=Non|Anti
  l:1->l:?Xl{		//base
    l:?r-> ?Yl {}
}
}
?L <- semanticon::(?Xl.sem).(lex) 
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+"A"+?r;		// matches the sem node with the name of LF
?Yr.dpos=N;			// actant must be a noun
not ?F.merged=yes;		// The collocate must not be merged with the base
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
  ]
  rightside = [
rc:?Yr {				// rth actant
  rc:<=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{ 
    <=>?Wl   				// LF + Anti|Non
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{ 	// base  
      <=> ?Xl  				
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created*/
Sem<=>DSynt modifier : modifier
[
  leftside = [
l:?Xl{							// LF node
  sem=Magn|Ver|Bon|Pos|AntiMagn|AntiBon|AntiPos|AntiVer	// LF name
  l:1-> ?Yl {}						// base
}
?F <- lexicon::(?Yr.dlex).(lf)
  ]
  conditions = [
?F.name=?Xl.sem; 			// matches the sem node with the name of LF
not lf::(?Yr.dlex).dpos; 		// ?Yr is not a LF
not ?F.merged=yes;			// The collocate must not be merged with the base
  ]
  rightside = [
rc:?Yr {			// base
  rc:<=> ?Yl
  lf::(Mod).(gp).(L)-> ?Xr{     // modifier
    <=> ?Xl
    dlex=?F.value
    lf=?F.name
    base=?Yr.dlex
    dpos=lf::(mod).dpos
    dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created*/
Sem<=>DSynt disabled Epit : no_patterns
[
  leftside = [
l:?Xl{}					// base
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="Epit";
//?Xr.dpos=N;
//?Xr.dsynt=OK;
?Xr.dpos=N or (not ?Xr.dpos);
  ]
  rightside = [
rc:?Xr { rc:<=> ?Xl			// Base
	dlex=?L
	dpos=lexicon::(?L).dpos
	dsynt=OK
  lf::(Epit).(gp).(L)-> ?Zr{		// LF
       dlex=?F.value
       dpos=lf::(Epit).dpos
       dsynt=OK
       lf=?F.name
       base=?Xr.dlex
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created*/
Sem<=>DSynt disabled Figur : no_patterns
[
  leftside = [
l:?Xl{}				// base
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="Figur" or ?F.name="Gener";
not ?Zr.dpos=V;
  ]
  rightside = [
rc:?Zr { rc:<=> ?Xl // LF
  split=top
  dlex=?F.value
  dpos=N
  dsynt=OK
  // Base of the collocation:
  lf::(Figur).(gp).(L)-> ?Xr{ <=> ?Xl
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created*/
Sem<=>DSynt disabled Involv : no_patterns
[
  leftside = [
l:?Zl {			// LF	
  sem=Involv
  l:1->l:?Xl{}		// base
  l:2->?Yl{}		// what is affected
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem;
not ?Zr.dsynt=OK;		// ?Zr must not be lexicalized
not ?F.merged=yes;		// The collocate must not be merged with the base
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl //?Xl			//Involv
  dlex=?F.value		
  dpos=V
  dsynt=OK
  tense=?Xl.tense
  voice=ACT
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// Base
       dpos=lexicon::(?L).(dpos)
       dlex=?L // won't work if ?Xr should be a LF
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// what is affected
       dpos=lf::(?F).(gp).(lf::(?F).(gp).(X1)).(dpos)
       finiteness=lexicon::(lexicon::(?L).(?F)).(gp).(lf::(?F).(gp).(X1)).(finiteness)
       mood=lexicon::(lexicon::(?L).(?F)).(gp).(lf::(?F).(gp).(X1)).(mood)
       subject=lexicon::(lexicon::(?L).(?F)).(gp).(lf::(?F).(gp).(X1)).(subject)
       det=lexicon::(lexicon::(?L).(?F)).(gp).(lf::(?F).(gp).(X1)).(det)
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt Ngov_loc : nominal_governor
[
  leftside = [
l:?Zl{						// Loc
  sem=Locin|Locab|Locad
  l:1->?Wl{}
  l:2->l:?Xl{					//NgoVsem
    sem=Sing|Mult|Culm|Germ|Centr|Cap|Equip
    l:1-> l:?Yl {}       				// NGoVsem base
}
}
?L <- semanticon::(?Yl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+?Xl.sem;		// matches the sem node with the name of LF
?Wr.dsynt=OK;				// wait for Wr to be lexicalized
?Wr.dpos=V;    				// must be a verb
  ]
  rightside = [
rc: ?Wr {  <=> ?Wl  			// main node
   lf::(?F.name).(gp).(X1)->
     ?Xr {  <=> ?Xl <=>?Zl		// Locx_NGoVsem 
     dlex=?F.value
     lf=?F.name
     dpos=lf::(NGov).dpos
     dsynt=OK
     lf::(?F.name).(gp).(L)-> ?Yr{   	// Base
        <=> ?Yl
	dlex=?L
        dpos=lf::(?F.name).dpos
	synt=OK
      }
}
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt Ngov_sem : nominal_governor
[
  leftside = [
l:?Xl{			// LF
  sem=Sing|Mult|Culm|Germ|Centr|Cap|Equip
  l:1-> l:?Yl {}		// base
}
?L <- semanticon::(?Yl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Xl.sem;			// matches the sem node with the name of LF 
  ]
  rightside = [
rc: ?Xr { 				// LF
     <=> ?Xl
     dlex=?F.value
     lf=?F.value
     base=?L
     dpos=lf::(NGov).dpos
     dsynt=OK
     lf::(NGov).(gp).(L)-> ?Yr{ 	// Base
        <=> ?Yl
	dlex=?L
        dpos=lf::(NGov).dpos
	dsynt=OK
      }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt case : preposition_case
[
  leftside = [
l:?Zl{					// LF
  sem=Locin|Locab|Locad|Instr|Caus
  l:?l-> l:?Xl {} 			// action
  l:?r-> l:?Yl {} 			// base
}
?L <- semanticon::(?Yl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem or (?F.name="Propt" and ?Zl.sem="Caus");
// matches the sem node with the name of LF
?Xr.dpos=V;    				// must be a verb
?Xr.dsynt=OK;  				// wait for X to be lexicalized
not ?F.merged=yes;			// The collocate must not be merged with the base
not ?F.value;
  ]
  rightside = [
rc:?Xr { rc:<=> ?Xl  			// main node
   lf::(Loc).(gp).(X1)->
   ?Yr {
        <=> ?Yl
	dpos=lf::(?L).(dpos)
	dlex=?L
	dsynt=OK
	case=?F.case
        lf=?F.name
    	base=?L
     }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt preposition : preposition_case
[
  leftside = [
l:?Zl{					// LF
  sem=Locin|Locab|Locad|Instr|Caus
  l:?l-> l:?Xl {} 			// action
  l:?r-> l:?Yl {} 			// base
}
?L <- semanticon::(?Yl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem or (?F.name="Propt" and ?Zl.sem="Caus");
// matches the sem node with the name of LF
?Xr.dpos=V or ?Xr.dpos=Adj;             // must modify a verb or adjective
?Xr.dsynt=OK;  				// wait for X to be lexicalized
not ?F.merged=yes;			// The collocate must not be merged with the base
not ?F.case;
  ]
  rightside = [
rc:?Xr { rc:<=> ?Xl  			// main node
   lf::(Loc).(gp).(X1)->
   ?Zr {
        <=> ?Zl 		// Locx|Propt|Instr
	dpos=lf::(Loc).(dpos)
	dlex=?F.value
	dsynt=OK
        lf=?F.name
    	base=?L
        lf::(Loc).(gp).(L)-> ?Yr{ <=> ?Yl	// base
	   dlex=?L
	   dpos=N		//must be a noun
	   dsynt=OK
           definiteness=?F.definiteness
	}
     }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Vreal_0 : realisation_verbs
[
  leftside = [
l:?Wl{				// LF
  sem=Real|AntiReal
  l:1-> l:?Xl{}  		// base
  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+"0" or 
(?F.name="AntiFact0" and ?Wl.sem=lf::(?F.name).(sem)) or 
(?F.name="Fact0" and ?Wl.sem=lf::(?F.name).(sem));
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl			// Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Vreal_i : realisation_verbs
[
  leftside = [
l:?Wl{				// LF Real
  sem=Real|AntiReal
  l:1-> l:?Xl{  		// base
      l:?r-> ?Yl {}		// rth actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+?r  or
(?F.name="Labreal"+?r and ?Wl.sem=lf::(?F.name).(sem)) or
(?F.name="AntiLabreal"+?r and lf::(?F.name).(sem)=?Wl.sem) or 
(?F.name="Fact"+?r and lf::(?F.name).(sem)=?Wl.sem) or 
(?F.name="AntiFact"+?r and lf::(?F.name).(sem)=?Wl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl 			// Vreal
  dlex=?F.value
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Vreal_ij : realisation_verbs
[
  leftside = [
l:?Wl{				// LF
  sem=Real|AntiReal
  l:1-> l:?Xl{  		// base
      l:?r-> ?Yl {}		// rth actant
      l:?l-> ?Zl {}		// lth actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+?r+?l or
(?F.name="Labreal"+?r+?l and ?Wl.sem=lf::(?F.name).(sem)) or
(?F.name="AntiLabreal"+?r+?l and lf::(?F.name).(sem)=?Wl.sem) or 
(?F.name="Fact"+?r+?l and lf::(?F.name).(sem)=?Wl.sem) or 
(?F.name="AntiFact"+?r+?l and lf::(?F.name).(sem)=?Wl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl			// Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Ar{ <=> ?Zl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vreal_0 : realisation_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}			// agent
  l:2-> l:?Zl{}
}
l:?Zl{
   sem=Real|AntiReal
   l:1->l:?Xl{			// base
     l:?r->?Yl{}		// agent
  }	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+"0" or 
(?F.name=?Cl.sem+?r+"AntiFact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+?r+"Fact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Real
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vreal_i : realisation_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}				// agent
  l:2-> l:?Zl {}
}
l:?Zl{
  sem=Real|AntiReal
  l:1->l:?Xl{
      l:?r->?Yl {}		// agent =  rth actant
      l:?l->?Wl {}			// lth actant
    }	
  }		
	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+?l or 
(?F.name=?Cl.sem+?r+"AntiFact"+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+?r+"Fact"+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+?r+"Labreal"+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+?r+"AntiLabreal"+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vreal_ij : realisation_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}				// agent
  l:2-> l:?Zl {}
}
l:?Zl{
  sem=Real|AntiReal
  l:1->l:?Xl{
      l:?r->?Yl {}		// agent =  rth actant
      l:?l->?Wl {}			// lth actant
      l:?s->?Ul {}			// sth actant
    }	
  }		
	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+?l+?s or 
(?F.name=?Cl.sem+?r+"AntiFact"+?l+?s and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+?r+"Fact"+?l+?s and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+?r+"Labreal"+?l+?s and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+?r+"AntiLabreal"+?l+?s and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Yr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(?s)-> ?Ur{ <=> ?Ul	// sth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?s)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vreal_0 : realisation_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// real
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem+"0" or 
(?F.name=?Al.sem+?r+?Cl.sem+"AntiFact0" and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?r+?Cl.sem+"Fact0" and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vreal_i : realisation_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// real
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
  l:?l-> ?Yl{}		// lth actant
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem+?l or 
(?F.name=?Al.sem+?r+?Cl.sem+"AntiFact"+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?r+?Cl.sem+"Fact"+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or
(?F.name=?Al.sem+?r+?Cl.sem+"Labreal"+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?r+?Cl.sem+"AntiLabreal"+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Yr{ <=> ?Yl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vreal_ij : realisation_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// real
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
  l:?l-> ?Yl{}		// lth actant
  l:?s-> ?Wl{}		// sth actant
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem+?l+?s or 
(?F.name=?Al.sem+?r+?Cl.sem+"AntiFact"+?l+?s and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?r+?Cl.sem+"Fact"+?l+?s and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or
(?F.name=?Al.sem+?r+?Cl.sem+"Labreal"+?l+?s and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?r+?Cl.sem+"AntiLabreal"+?l+?s and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Yr{ <=> ?Yl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(?s)-> ?Wr{ <=> ?Wl	// sth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?s)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vreal_0 : realisation_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl{}
  l:1-> ?Ul{}			// agent
}
l:?Zl{
   sem=Real|AntiReal
   l:1->l:?Xl{}		// base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+"0" or 
(?F.name=?Cl.sem+"AntiFact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Real
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vreal_i : realisation_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}
  l:1-> ?Ul{}				// agent
}
?Zl{
  sem=Real|AntiReal
  l:1->l:?Xl{}		
}
l:?Xl {					//base	
      l:?r->?Yl {}			// rth actant
    }		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r or 
(?F.name=?Cl.sem+"AntiFact"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+"Labreal"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"AntiLabreal"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vreal_ij : realisation_verbs
[
  leftside = [
l:?Cl{				// caus
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}
  l:1-> ?Ul{}			// agent
}
?Zl{
  sem=Real|AntiReal		// LF
  l:1->l:?Xl{}		
}
l:?Xl {				// base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r+?l or 
(?F.name=?Cl.sem+"AntiFact"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+"Labreal"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"AntiLabreal"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(x1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vreal_0 : realisation_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base
  }
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem+"0" or 
(?F.name=?Al.sem+?Cl.sem+"AntiFact0" and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?Cl.sem+"Fact0" and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vreal_i : realisation_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem+?r or 
(?F.name=?Al.sem+?Cl.sem+"AntiFact"+?r and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?Cl.sem+"Fact"+?r and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or
(?F.name=?Al.sem+?Cl.sem+"Labreal"+?r and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?Cl.sem+"AntiLabreal"+?r and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vreal_ij : realisation_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
    sem=Real|AntiReal
    l:1->l:?Xl{}		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem+?r+?l or 
(?F.name=?Al.sem+?Cl.sem+"AntiFact"+?r+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?Cl.sem+"Fact"+?r+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or
(?F.name=?Al.sem+?Cl.sem+"Labreal"+?r+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem) or 
(?F.name=?Al.sem+?Cl.sem+"AntiLabreal"+?r+?l and lf::(?F.name).(sem)=?Al.sem+?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vreal
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vreal_0 : realisation_verbs
[
  leftside = [
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
   sem=Real|AntiReal
   l:1->l:?Xl{}			// base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+"0" or 
(?F.name=?Cl.sem+"AntiFact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact0" and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// Phase + Real
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vreal_i : realisation_verbs
[
  leftside = [
l:?Cl{					// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl {}
}
l:?Zl{
  sem=Real|AntiReal
  l:1->?Xl{}		
}
l:?Xl {					//base	
      l:?r->?Yl {}			// rth actant
    }		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r+?l or 
(?F.name=?Cl.sem+"AntiFact"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+"Labreal"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"AntiLabreal"+?r and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// Phase + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vreal_ij : realisation_verbs
[
  leftside = [
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl {}
}
l:?Zl{
  sem=Real|AntiReal			// LF
  l:1->?Xl{}		
}
l:?Xl {				// base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r+?l or 
(?F.name=?Cl.sem+"AntiFact"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"Fact"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or
(?F.name=?Cl.sem+"Labreal"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem) or 
(?F.name=?Cl.sem+"AntiLabreal"+?r+?l and lf::(?F.name).(sem)=?Cl.sem+?Zl.sem);
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Yr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// Phase + Vreal
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos) 
 }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt Vsem_0 : semantic_verbs
[
  leftside = [
l:?Wl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{}  		// base
  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl             // Vsem
  dlex=?F.value
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str of the corresponding LFs have been created.*/
Sem<=>DSynt Vsem_i : semantic_verbs
[
  leftside = [
l:?Wl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{  		// base
      l:?r-> ?Yl {}		// actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl			// Vsem
  dlex=?F.value
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt Vsem_ij : semantic_verbs
[
  leftside = [
l:?Wl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{  		// base
      l:?r-> ?Yl {}		// rth actant
      l:?l-> ?Zl {}		// lth actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Wl.sem+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Wl			// Vsem
  dlex=?F.value
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Ar{ <=> ?Zl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsem_0 : semantic_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}			// agent
  l:2-> l:?Zl{}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon
   l:1->l:?Xl{			// base
     l:?r->?Yl{}		// source
  }	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsem_i : semantic_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}				// agent
  l:2-> l:?Zl {}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->l:?Xl{
      l:?r->?Yl {}		// agent =  rth actant
      l:?l->?Wl {}			// lth actant
    }	
  }		
	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsem_ij : semantic_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:1-> ?Yl{}				// agent
  l:2-> l:?Zl {}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->l:?Xl{
      l:?r->?Yl {}		// agent =  rth actant
      l:?l->?Wl {}			// lth actant
      l:?s->?Ul {}			// sth actant
    }	
  }		
	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+?l+?s;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(?s)-> ?Ur{ <=> ?Ul	// sth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?s)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsem_0 : semantic_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// sem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsem_i : semantic_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// real
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
  l:?l-> ?Yl{}		// lth actant
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Yr{ <=> ?Yl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsem_ij : semantic_verbs
[
  leftside = [
l:?Al{				// Caus
  sem=Liqu|Caus|Perm
  l:1-> ?Ul {}			// agent
  l:2-> l:?Cl {}
}
l:?Cl{				// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{				// sem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1->l:?Xl{}		// base	
  }
l:?Xl{			
  l:?r-> ?Ul{}		// rth actant = agent
  l:?l-> ?Yl{}		// lth actant
  l:?s-> ?Wl{}		// sth actant
}		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?r+?Cl.sem+?Zl.sem+?l+?s;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent = rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Yr{ <=> ?Yl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(?s)-> ?Wr{ <=> ?Wl	// sth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?s)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vsem_0 : semantic_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl{}
  l:1-> ?Ul{}			// agent
}
?Zl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon
   l:1->l:?Xl{}			// base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Real
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*FIXME: block application if agent is actant of base predicate*/
Sem<=>DSynt causX_Vsem_i : semantic_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}
  l:1-> ?Ul{}				// agent
}
?Zl{					// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->l:?Xl{}		
}
l:?Xl {					//base	
      l:?r->?Yl {}			// rth actant
    }		
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
not ?Yl.sem=?Ul.sem;
?F.name=?Cl.sem+?Zl.sem+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
not (?Cl 1-> ?Yl);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*FIXME: recopy last two conditions to other causX rules*/
Sem<=>DSynt causX_Vsem_ij : semantic_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}
  l:1-> ?Ul{}				// agent
}
?Zl{					// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->l:?Xl{}		
}
l:?Xl {				// base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
not (?Cl 1-> ?Yl);
not (?Cl 1-> ?wl);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl		// causative + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos) 
 }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsem_0 : semantic_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon
    l:1->l:?Xl{}			// base
  }
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsem_i : semantic_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1->l:?Xl{}		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
not (?Cl 1-> ?Yl);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsem_ij : semantic_verbs
[
  leftside = [
l:?Al{				// caus
  sem=Liqu|Caus|Perm
  l:2-> l:?Cl {}
  l:1-> ?Ul {}			// agent
}
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl{}
}
l:?Zl{
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1->l:?Xl{}		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Al.sem+?Cl.sem+?Zl.sem+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
not (?Cl 1-> ?Yl);
not (?Cl 1-> ?wl);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Al // Caus + Phase + Vsem
  dlex=?F.value
  dpos=V
  lf=?F.name
  base=?L
  dsynt=OK
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Ur{ <=> ?Ul	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vsem_0 : semantic_verbs
[
  leftside = [
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl {}
}
?Zl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon
  l:1->l:?Xl{}			// base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl 	// Phase + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vsem_i : semantic_verbs
[
  leftside = [
l:?Cl{				//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl {}
}
?Zl{				// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->?Xl{}		
}
l:?Xl{  				// base
   l:?r-> ?Yl {}		// actant
  }
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// Phase + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl	// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl   // rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt phase_Vsem_ij : semantic_verbs
[
  leftside = [
l:?Cl{					//phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Zl {}
}
?Zl{					// LF
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1->?Xl{}		
}
l:?Xl{				// base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Wl {}		// lth actant
}	
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// Phase + Vsem
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl	// base
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl   // rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos) 
 }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl   // lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt Vsupp_0 : support_verbs
[
  leftside = [
l:?Xl{}		// base
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="Oper0" or ?F.name="Func0";	// matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Xl				// LF
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*FIXME
Original version of the rule.

We get lots of duplicates. For this rule even restricted to Oper1 with an entry that has no other LF, we get 5 duplicates. The culprit seems to be
  ?F <- lexicon::(?L).(lf)
Replacing
  ?L <- semanticon::(?Xl.sem).(lex)
with a deterministic instruction makes no difference.*/
Sem<=>DSynt Vsupp_i : support_verbs
[
  leftside = [
l:?Xl{  		// base
  l:?r-> ?Yl {}		// rth actant
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="Oper"+?r or ?F.name="Func"+?r or ?F.name="Labor"+?r; // matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Xl				// LF
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
       dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created*/
Sem<=>DSynt Vsupp_ij : support_verbs
[
  leftside = [
l:?Xl{  			// base
  l:?r-> ?Yl {}			// rth actant
  l:?l-> ?Wl {}			// lth actant
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="Oper"+?r+?l or ?F.name="Func"+?r+?l or ?F.name="Labor"+?r+?l;
					// matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Xl				// LF
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)  
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)  
}
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsupp_0 : support_verbs
[
  leftside = [
l:?Zl {				// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl{}			// agent
  l:2->l:?Xl{			// base	
     l:?r->?Yl{}		// agent
  }
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+?r+"Oper0" or ?F.name=?Zl.sem+?r+"Func0";
lexicon::(?L).dpos;		// makes sure ?L has a dpos
semanticon::(?Xl.sem).lex;	// makes sure ?Xl has a lexicalisation
not ?Xr.dsynt=OK;		// must not be lexicalized
not ?Zr.dsynt=OK;		// must not be lexicalized
?Zr.dpos=V or (not ?Zr.dpos);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value		
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsupp_i : support_verbs
[
  leftside = [
l:?Zl {			// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl{}		// agent
  l:2->l:?Xl{		// base
    l:?r->?Yl{}		// source
    l:?l-> ?Wl {}	// lth actant
  }		
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+?r+"Oper"+?l or ?F.name=?Zl.sem+?r+"Func"+?l or ?F.name=?Zl.sem+?r+"Labor"+?l;
lexicon::(?L).dpos;		// makes sure ?L has a dpos
semanticon::(?Xl.sem).lex;	// makes sure ?Xl has a lexicalisation
not ?Xr.dsynt=OK;		// must not be lexicalized
not ?Zr.dsynt=OK;		// must not be lexicalized
?Zr.dpos=V or (not ?Zr.dpos);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
 }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_Vsupp_ij : support_verbs
[
  leftside = [
l:?Zl {			// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl{}		// agent
  l:2->l:?Xl{		// base
    l:?r->?Yl{}		// agent
    l:?l-> ?Wl {}		// lth actant
    l:?s-> ?Ul {}		// sth actant
  }		
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+?r+"Oper"+?l+?s or ?F.name=?Zl.sem+?r+"Func"+?l+?s or ?F.name=?Zl.sem+?r+"Labor"+?l+?s;
lexicon::(?L).dpos;		// makes sure ?L has a dpos
semanticon::(?Xl.sem).lex;	// makes sure ?Xl has a lexicalisation
not ?Xr.dsynt=OK;		// must not be lexicalized
not ?Zr.dsynt=OK;		// must not be lexicalized
?Zr.dpos=V or (not ?Zr.dpos);
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent	  
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
}
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)  
  }
  lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// sth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)  
}
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsupp_0 : support_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl {}			// agent
  l:2-> l:?Zl {			// phase
    sem=Incep|Fin|Cont|Prepar|Prox|Non
    l:1-> l:?Xl {}		// base
  }
}
l:?Xl{			// base
  l:?r->?Yl{}		// source
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+"Oper0" or ?F.name=?Cl.sem+?r+?Zl.sem+"Func0";
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	//causative + phase + Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsupp_i : support_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl {}			// agent
  l:2-> l:?Zl {			// phase
    sem=Incep|Fin|Cont|Prepar|Prox|Non
    l:1->l:?Xl {}		//base
      }
}
l:?Xl{			// base
  l:?r->?Yl{}		// agent
  l:?l-> ?Wl {}		// lth actant
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+"Oper"+?l or ?F.name=?Cl.sem+?r+?Zl.sem+"Func"+?l or ?F.name=?Cl.sem+?r+?Zl.sem+"Labor"+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// causative + phase +Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causInt_phase_Vsupp_ij : support_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:1->?Yl {}			// agent
  l:2-> l:?Zl {			// phase
    sem=Incep|Fin|Cont|Prepar|Prox|Non
    l:1->l:?Xl {}		//base
      }
}
l:?Xl{			// base
  l:?r->?Yl{}		// agent
  l:?l-> ?Wl {}		// lth actant
  l:?s-> ?Ul {}		// sth actant
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?r+?Zl.sem+"Oper"+?l+?s or ?F.name=?Cl.sem+?r+?Zl.sem+"Func"+?l+?s or ?F.name=?Cl.sem+?r+?Zl.sem+"Labor"+?l+?s;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// causative + phase +Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl	// lth actant
   dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
  lf::(?F.name).(gp).(?s)-> ?Ur{ <=> ?Ul	// sth actant
   dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?s)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vsupp_0 : support_verbs
[
  leftside = [
l:?Zl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{}		// base	
  l:1->?Yl{}		// agent	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Func0" or ?F.name=?Zl.sem+"Oper0";
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		//base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
}
  ]
  correspondence = [

  ]
]
/*FIXME: this rule doesn't work!*/
Sem<=>DSynt causX_Vsupp_i : support_verbs
[
  leftside = [
l:?Zl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{		// base
    l:?r-> ?Wl {}	// rth actant
   }
  l:1->?Yl{}		// agent	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Oper"+?r or ?F.name=?Zl.sem+"Func"+?r or ?F.name=?Zl.sem+"Labor"+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Wr{ <=> ?Wl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_Vsupp_ij : support_verbs
[
  leftside = [
l:?Zl {			// causative 
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{		// base
    l:?r-> ?Wl {}	// rth actant
    l:?l-> ?Ul {}	// lth actant
   }
  l:1->?Yl{}		// agent	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Oper"+?r+?l or ?F.name=?Zl.sem+"Func"+?r+?l or ?F.name=?Zl.sem+"Labor"+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl	// causative + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos)
  }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl  	// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Wr{ <=> ?Wl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsupp_0 : support_verbs
[
  leftside = [
l:?Cl{					// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}			// phase
  l:1->?Yl {}				// agent
}
l:?Zl {					// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1-> l:?Xl {}			//base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+"Oper0" or ?F.name=?Cl.sem+?Zl.sem+"Func0";
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// causative + Phase + Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsupp_i : support_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}		// phase
  l:1->?Yl {}			// agent
  }
l:?Zl {				//phase
    sem=Incep|Fin|Cont|Prepar|Prox|Non
    l:1->l:?Xl {		//base
      l:?r->?Wl {}		// rth actant
    }	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+"Oper"+?r or ?F.name=?Cl.sem+?Zl.sem+"Func"+?r  or ?F.name=?Cl.sem+?Zl.sem+"Labor"+?r;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// causative + phase + Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Wr{ <=> ?Wl	// rth actant
dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt causX_phase_Vsupp_ij : support_verbs
[
  leftside = [
l:?Cl{				// causative
  sem=Caus|Liqu|Perm
  l:2-> l:?Zl {}		// phase
  l:1->?Yl {}			// agent
  }
l:?Zl {				// phase
    sem=Incep|Fin|Cont|Prepar|Prox|Non
    l:1->l:?Xl {		// base
      l:?r->?Wl {}		// rth actant
      l:?l-> ?Ul {}		// lth actant
    }	
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Cl.sem+?Zl.sem+"Oper"+?r+?l or ?F.name=?Cl.sem+?Zl.sem+"Func"+?r+?l or ?F.name=?Cl.sem+?Zl.sem+"Labor"+?r+?l;
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Zr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Cl	// causative + phase + Vsupp
  split=top
  dlex=?F.value
  dpos=V
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(X1)-> ?Yr{ <=> ?Yl 	// agent
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(X1)).(dpos) 
 }
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Wr{ <=> ?Wl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)
  }
  lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt phase_Vsupp_0 : support_verbs
[
  leftside = [
l:?Zl {			// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1->l:?Xl {}		//base
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Oper0" or ?F.name=?Zl.sem+"Func0";	// matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Yr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl		//phase + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		//base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt phase_Vsupp_i : support_verbs
[
  leftside = [
l:?Zl {			// phase
  sem=Incep|Fin|Cont|Prox|Prepar|Non
  l:1->l:?Xl{  		// base
    l:?r-> ?Yl {}	// rth actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Oper"+?r or ?F.name=?Zl.sem+"Func"+?r or ?F.name=?Zl.sem+"Labor"+?r;
// matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Yr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl 	// phase
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl		// base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)  
 }
}
  ]
  correspondence = [

  ]
]
/*The sem.str template created
The dsynt.str template created.*/
Sem<=>DSynt phase_Vsupp_ij : support_verbs
[
  leftside = [
l:?Zl {			// phase
  sem=Incep|Fin|Cont|Prepar|Prox|Non
  l:1->l:?Xl{  		// base
    l:?r-> ?Yl {}	// rth actant
    l:?l-> ?Wl {}       // lth actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name=?Zl.sem+"Oper"+?r+?l or ?F.name=?Zl.sem+"Func"+?r+?l or ?F.name=?Zl.sem+"Labor"+?r+?l;
// matches the sem node with the name of LF
semanticon::(?Xl.sem).lex;		// makes sure ?Xl has a lexicalisation
lexicon::(?L).dpos;			// makes sure ?L has a dpos
not ?Xr.dsynt=OK;			// ?Xr must not be lexicalised
not ?Zr.dsynt=OK;			// ?Yr must not be lexicalised
?Zr.dpos=V or (not ?Zr.dpos);		// ?Zr must be a verb
  ]
  rightside = [
rc:?Zr { rc:<=> ?Zl		// Phase + Vsupp
  split=top
  dlex=?F.value
  dsynt=OK
  lf=?F.name
  base=?L
  lf::(?F.name).(gp).(L)-> ?Xr{ <=> ?Xl	 // base
       split=bottom
       dpos=lexicon::(?L).(dpos)
       dlex=?L 
       dsynt=OK
  }
  lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl  // rth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?r)).(dpos)  
}
  lf::(?F.name).(gp).(?l)-> ?Wr{ <=> ?Wl  // lth actant
  dpos=lexicon::(?F.value).(gp).(lf::(?F.name).(gp).(?l)).(dpos)  
 }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt block_definiteness : ENG
[
  leftside = [
?Xl
  ]
  conditions = [

  ]
  rightside = [
rc:?Xr{
  rc:<=> ?Xl
  definiteness=NO
  rc:?r-> rc:?Yr { rc:case=GEN }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Zl{			// Real
  sem=Real|AntiReal
  l:1-> l:?Xl{}
}
l:?Xl{			// base
    l:?r-> ?Yl {}	// rth actant
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Zl.sem+?r or
(?F.name="A2AntiFact"+?r and ?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2Fact"+?r and ?Zl.sem=lf::(?F.name).(sem));
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Yr {						// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{   <=> ?Zl 		// Ai node
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Zl{			//Real
  sem=Real|AntiReal
  l:1-> l:?Xl{}		//base
  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Zl.sem+"0" or
(?F.name="A1AntiFact0" and ?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1Fact0" and ?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {					// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Yr{  <=> ?Zl   // Ai
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Zl{			//Real
  sem=Real|AntiReal
  l:1-> l:?Xl{}
}
l:?Xl{			//base
    l:?r-> ?Yl {}	// rth actant
 }		
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Zl.sem+?r or
(?F.name="A1AntiFact"+?r and ?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1Fact"+?r and ?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?Yr.dsynt=OK;  		// actant must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {					// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Zr {  <=> ?Zl   	// Ai
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   		// rth actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->?Yl {}		// agent
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> ?Xl {} 	// base
  }
}
?Xl {				//base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Zl.sem+?l or
(?F.name="A3"+?Wl.sem+?r+"AntiFact"+?l and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A3"+?Wl.sem+?r+"Fact"+?l and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// rth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Zl <=> ?Wl			// Ai + causative + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> ?Xl {} 	// base
  }
}
?Xl {				//base	
      l:?r->?Yl {}		// source
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Zl.sem+"0" or
(?F.name="A2"+?Wl.sem+?r+"AntiFact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?r+"Fact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> ?Xl {} 	// base
  }
}
?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Zl.sem+?l or
(?F.name="A2"+?Wl.sem+?r+"AntiFact"+?l and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?r+"Fact"+?l and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vreal_cause : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Zl {}		// Vreal
  l:1-> ?Ul {}		// agent
}
?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> l:?Xl { 	// base
    l:?r-> ?Ul {}	// agent
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?r+?Zl.sem+"0" or
(?F.name="A1"+?Wl.sem+?r+"AntiFact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1"+?Wl.sem+?r+"Fact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;		// base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
    <=> ?Zl <=> ?Wl			 // Ai + causative+  Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->?Yl {}		// agent
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> l:?Xl {} 		// base
  }
l:?Xl {			//base	
      l:?r->?Yl {}	// rth actant
      l:?l->?Ul {}	// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Al.sem+?Zl.sem+?l or
(?F.name="A3"+?Wl.sem+?r+?Al.sem+"AntiFact"+?l and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A3"+?Wl.sem+?r+?Al.sem+"Fact"+?l and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// lth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?l)-> ?Zr{  
    <=> ?Zl <=> ?Wl <=> ?Al	// Ai + causative + Phase + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
    sem=Real|AntiReal
    l:1-> l:?Xl {} 	// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Al.sem+?Zl.sem+"0" or
(?F.name="A2"+?Wl.sem+?r+?Al.sem+"AntiFact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?r+?Al.sem+"Fact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + causative + Phase + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
    sem=Real|AntiReal
    l:1-> l:?Xl {} 	// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Al.sem+?Zl.sem+?l or
(?F.name="A2"+?Wl.sem+?r+?Al.sem+"AntiFact"+?l and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?r+?Al.sem+"Fact"+?l and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + causative + Phase + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vreal_cause : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Prox|Prepar|Non
    l:1-> l:?Zl {}	// Vreal
  }		
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> l:?Xl { 	// base
    l:?r-> ?Ul {}	// agent
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?r+?Al.sem+?Zl.sem+"0" or
(?F.name="A1"+?Wl.sem+?r+?Al.sem+"AntiFact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1"+?Wl.sem+?r+?Al.sem+"Fact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;		// base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + causative + Phase + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem+?r or
(?F.name="A3"+?Wl.sem+"AntiFact"+?r and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A3"+?Wl.sem+"Fact"+?r and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Yr {				// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Zl <=> ?Wl			// Ai + causative + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> l:?Xl {} 	// base
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Zl.sem+"0" or
(?F.name="A2"+?Wl.sem+"AntiFact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+"Fact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Zl{		// Vreal
    sem=Real|AntiReal
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Zl.sem+?r or
(?F.name="A2"+?Wl.sem+"AntiFact"+?r and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+"Fact"+?r and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vreal_cause : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Zl {}
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> l:?Xl {} 	// base
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Zl.sem+"0" or
(?F.name="A1"+?Wl.sem+"AntiFact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1"+?Wl.sem+"Fact0" and ?Wl.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;		// base must not be lexicalized
not (?Xl 1->?Ul or ?Xl 2->?Ul or ?Xl 3->?Ul);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
    <=> ?Zl <=> ?Wl			 // Ai + causative+  Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> ?Xl {} 		// base
  }
l:?Xl {				//base	
      l:?r->l:?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Al.sem+?Zl.sem+?r or
(?F.name="A3"+?Wl.sem+?Al.sem+"AntiFact"+?r and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A3"+?Wl.sem+?Al.sem+"Fact"+?r and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Yr {				// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> ?Xl {} 		// base
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Al.sem+?Zl.sem+"0" or
(?F.name="A2"+?Wl.sem+?Al.sem+"AntiFact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?Al.sem+"Fact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
//?Xr.dpos=N;
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> ?Xl {} 		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Al.sem+?Zl.sem+?r or
(?F.name="A2"+?Wl.sem+?Al.sem+"AntiFact"+?r and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+?Al.sem+"Fact"+?r and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vreal
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vreal_cause : Ai_Vreal
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vreal
  }
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vreal
  sem=Real|AntiReal
  l:1-> l:?Xl {} 	// base
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Al.sem+?Zl.sem+"0" or
(?F.name="A1"+?Wl.sem+?Al.sem+"AntiFact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A1"+?Wl.sem+?Al.sem+"Fact0" and ?Wl.sem+?Al.sem+?Zl.sem=lf::(?F.name).(sem));
not ?Xr.dsynt=OK;		// base must not be lexicalized
not (?Xl 1->?Ul or ?Xl 2->?Ul or ?Xl 3->?Ul);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vreal_actant : Ai_Vreal
[
  leftside = [
l:?Wl {				// Phase
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Real
    sem=Real|AntiReal
    l:1-> l:?Xl{		//base
      l:?r-> ?Yl {}		//actant
    }
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Zl.sem+?r or 
(?F.name="A2"+?Wl.sem+"AntiFact"+?r and ?Zl.sem=lf::(?F.name).(sem)) or
(?F.name="A2"+?Wl.sem+"Fact"+?r and ?Zl.sem=lf::(?F.name).(sem));
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Yr {				// actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Zl <=>?Wl			// Ai + Phase
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vreal_base_0 : Ai_Vreal
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Real
    sem=Real|AntiReal
    l:1-> l:?Xl{}		//base
  }  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem+"0" or
(?F.name="A1"+?Wl.sem+"AntiFact0" and lf::(?F.name).(sem)=?Wl.sem+?Zl.sem) or
(?F.name="A1"+?Wl.sem+"Fact0" and lf::(?F.name).(sem)=?Wl.sem+?Zl.sem);
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Yr{  
      <=> ?Zl <=> ?Wl   	// Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vreal_base_i : Ai_Vreal
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Real
    sem=Real|AntiReal
    l:1-> l:?Xl{		//base
      l:?r-> ?Yl {} 
    }		
  }  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem+?r or
(?F.name="A1"+?Wl.sem+"AntiFact"+?r and lf::(?F.name).(sem)=?Wl.sem+?Zl.sem) or
(?F.name="A1"+?Wl.sem+"Fact"+?r and lf::(?F.name).(sem)=?Wl.sem+?Zl.sem);
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{  
      <=> ?Zl <=> ?Wl   		// Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   	// rth actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{}
}
l:?Xl{			// base
    l:?r-> ?Yl {}	// rth actant
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Zl.sem+?r;
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Yr {					// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{   <=> ?Zl 	// Ai node
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Zl{			//Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{}		//base
  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Zl.sem;
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?Xl ?s->?Yl;	// makes sure the agent is not an actant of the base
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {					// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Zr{  <=> ?Zl   // Ai
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Zl{			//Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl{}
}
l:?Xl{			//base
    l:?r-> ?Yl {}	// rth actant
 }		
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Zl.sem+?r;
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?Yr.dsynt=OK;  		// actant must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {					// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Zr {  <=> ?Zl   	// Ai
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   		// rth actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1->?Yl {}		// agent
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Zl.sem+?l;
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// rth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?l)-> ?Zr{  
    <=> ?Zl <=> ?Wl			// Ai + causative + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1-> ?Yl{}		// agent
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// agent
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Zl.sem;
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Zl.sem+?l;
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsem_cause : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Zl {}		// Vsem
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl { 	// base
    l:?r-> ?Ul {}	// agent
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?r+?Zl.sem;
not ?Xr.dsynt=OK;		// base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
    <=> ?Zl <=> ?Wl			 // Ai + causative+  Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Wl {			// Causative
  sem=Caus|Perm|liqu
  l:1->?Yl {}		// agent
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 		// base
  }
l:?Xl {			//base	
      l:?r->?Yl {}	// rth actant
      l:?l->?Ul {}	// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Al.sem+?Zl.sem+?l;
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// lth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?l)-> ?Zr{  
    <=> ?Zl <=> ?Wl <=> ?Al	// Ai + Causative + Phase + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Wl {			// Causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Al.sem+?Zl.sem;
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + Causative + Phase + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Wl {			// Causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?r+?Al.sem+?Zl.sem+?l;
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + causative + Phase + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsem_cause : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Prox|Prepar|Non
    l:1-> l:?Zl {}	// Vsem
  }		
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl { 	// base
    l:?r-> ?Ul {}	// agent
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?r+?Al.sem+?Zl.sem;
not ?Xr.dsynt=OK;		// base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
      <=> ?Wl <=> ?Zl  <=> ?Al		// Ai + causative + Phase + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
  l:1->l:?Al{}
}
l:?Xl {				//base	
      l:?r->l:?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Zl.sem+?r;
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Yr {				// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Zl <=> ?Wl			// Ai + causative + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Al{}
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem;
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->l:?Al{}
  l:2->l:?Zl{		// Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl {} 	// base
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem+?r;
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  			// Ai + causative + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Vsem_cause : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Zl {}
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 	// base
  }
l:?Xl {}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Zl.sem;
not ?Xr.dsynt=OK;		// base must not be lexicalized
?Ur.dsynt=OK;
not (?Xl 1->?Ul or ?Xl 2->?Ul or ?Xl 3->?Ul);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
    <=> ?Zl <=> ?Wl			 // Ai + Caus +  Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vreal
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 		// base
  }
l:?Xl {				//base	
      l:?r->l:?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Al.sem+?Zl.sem+?r;
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Yr {				// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 		// base
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Al.sem+?Zl.sem;
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|Liqu
  l:1->l:?Bl{}
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 		// base
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Al.sem+?Zl.sem+?r;
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Bl or ?Xl 2->?Bl or ?Xl 3->?Bl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{ <=> ?Yl	// rth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_phase_Vsem_cause : Ai_Vsem
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Liqu|Perm
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Zl {} 	// Vsem
  }
  l:1-> ?Ul {}		// agent
}
l:?Zl{			// Vsem
  sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
  l:1-> l:?Xl {} 	// base
  }
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Al.sem+?Zl.sem;
not ?Xr.dsynt=OK;		// base must not be lexicalized
not (?Xl 1->?Ul or ?Xl 2->?Ul or ?Xl 3->?Ul);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Ur {				// agent
  <=> ?Ul
   lf::(?F.name).(gp).(X1)-> ?Zr { 
      <=> ?Wl <=> ?Zl  	<=> ?Al		// Ai + causative + Phase + Vreal
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsem_actant : Ai_Vsem
[
  leftside = [
l:?Wl {				// Phase
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl{		//base
      l:?r-> ?Yl {}		//actant
    }
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Zl.sem+?r;
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Yr {				// actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Zl <=>?Wl		// Ai + Phase + Vsem
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsem_base_0 : Ai_Vsem
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Vsem
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl{}		//base
  }  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Zl.sem;
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Yr{  
      <=> ?Zl <=> ?Wl   	// Ai node + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsem_base_i : Ai_Vsem
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Zl{			//Real
    sem=Manif|Degrad|Excess|Stop|Obstr|Son|Sympt|
  AntiManif|AntiDegrad|AntiExcess|AntiStop|AntiObstr|AntiSon|AntiSympt
    l:1-> l:?Xl{		//base
      l:?r-> ?Yl {} 
    }		
  }  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Zl.sem+?r;
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{  
      <=> ?Zl <=> ?Wl   		// Ai node + Phase + Vsem
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   	// rth actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Xl{		//base
  l:?r-> ?Yl {}	//actant
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+"Oper"+?r or ?F.name="A2"+"Func"+?r;	
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Yr {			    	// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{        // Ai node
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Xl{}		//base
  
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1Func0" or ?F.name="A2Oper0";	
not ?Xr.dsynt=OK;				// not sure if we have to keep it
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Yr{     // Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Xl{		//base
    l:?r-> ?Yl {} 	
  
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1Func"+?r or ?F.name="A2Oper"+?r;	
not ?Xr.dsynt=OK;				// not sure if we have to keep it
not ?S 1->?Xl and (?S.sem="Anti" or 
?S.sem="Incep" or
?S.sem="Fin" or
?S.sem="Cont");
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{   // Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   		// actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->?Yl {}		// agent
  l:2->l:?Xl {} 	// base
  
}
l:?Xl {			//base	
      l:?r->?Yl {}	// rth actant
      l:?l->?Ul {}	// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A3"+?Wl.sem+?r+"Func"+?l or "A2"+?Wl.sem+?r+"Oper"+?l;
?F.name="A2"+?Wl.sem+?r+"Oper"+?l;
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {				// lth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?l)-> ?Zr{  
    <=> ?Wl				 // Ai + causative 
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2-> l:?Xl {} 	//base	
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A2"+?Wl.sem+?r+"Func0" or "A3"+?Wl.sem+?r+"Oper0";
?F.name="A3"+?Wl.sem+?r+"Oper0";
not ?Xr.dsynt=OK;			// base must not be lexicalized
not ?Xr.dpos=V;
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl  		// Ai + causative 
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2-> l:?Xl {} 	//base	
  }
l:?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A2"+?Wl.sem+?r+"Func"+?l or "A3"+?Wl.sem+?r+"Oper"+?l;
?F.name="A3"+?Wl.sem+?r+"Oper"+?l;
not ?Xr.dsynt=OK;			// base must not be lexicalized
not ?Xr.dpos=V;
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl  		// Ai + causative 
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_Vsupp_cause : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:1-> ?Zl {}			//agent
  l:2->l:?Xl{}			//base   
  }
l:?Xl{				//base
  l:?r->?Zl {}			//actant	
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A1"+?Wl.sem+?r+"Oper0" or ?F.name="A1"+?Wl.sem+?r+"Func0";
?F.name="A1"+?Wl.sem+?r+"Oper0";
not ?F.merged=yes;					// The collocate must not be merged with the base
?Zr.dsynt=OK;  						// wait for Z to be lexicalized
  ]
  rightside = [
rc:?Zr {				// agent
  <=> ?Zl
   lf::(?F.name).(gp).(X1)-> ?Wr { 
    <=> ?Wl 		 		// Ai + causative
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1->?Yl {}		// agent
  l:2->l:?Al{		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Xl {} 	// Vsem
  }
}
l:?Xl {			//base	
      l:?r->?Yl {}	// rth actant
      l:?l->?Ul {}	// lth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?r+?Al.sem+"Func"+?l or ?F.name="A2"+?Wl.sem+?r+?Al.sem+"Oper"+?l;
?Ur.dpos=N;			// actant must be a noun
?Ur.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Ur {			// lth actant
  <=> ?Ul
  lf::(?F.name).(gp).(?l)-> ?Zr{  
   <=> ?Wl <=> ?Al		// Ai + causative + Phase
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  			// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// agent
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Xl {	//base	
      l:?r->?Yl {}	
      } 	
    }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A2"+?Wl.sem+?r+?Al.sem+"Func0" or "A3"+?Wl.sem+?r+?Al.sem+"Oper0";
?F.name="A3"+?Wl.sem+?r+?Al.sem+"Oper0";
not ?Xr.dsynt=OK;			// base must not be lexicalized
not (?Xl 1->?Ul or ?Xl 2->?Ul or ?Xl 3->?Ul);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl  <=> ?Al		// Ai + causative + Phase
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Wl {			// causative
  sem=Caus|Perm|liqu
  l:1-> ?Yl{}		// source
  l:2->l:?Al {		// Phase
    sem=Incep|Cont|Non|Prox|Prepar
    l:1-> l:?Xl {} 	//base	
  }
}
l:?Xl {				//base	
      l:?r->?Yl {}		// source
      l:?l->?Ul {}		// rth actant
    }	
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A2"+?Wl.sem+?r+?Al.sem+"Func"+?l or "A3"+?Wl.sem+?r+?Al.sem+"Oper"+?l;
?F.name="A3"+?Wl.sem+?r+?Al.sem+"Oper"+?l;
not ?Xr.dsynt=OK;			// base must not be lexicalized
  ]
  rightside = [
rc:?Xr {				// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
      <=> ?Wl  <=> ?Al		// Ai + causative + Phase
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?l)-> ?Ur{ <=> ?Ul	// lth actant
      }
    }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causInt_phase_Vsupp_cause : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:1-> ?Zl {}				//causative
  l:2->l:?Ul{				//phase
    sem=Incep|Fin|Cont|Prox|Prepar
    l:1->l:?Xl{	}			//base   
  }
}
l:?Xl{				//base
  l:?r->?Zl {}			//actant	
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?r+?Ul.sem+"Oper0" or ?F.name="A1"+?Wl.sem+?r+?Ul.sem+"Func0";	
not ?F.merged=yes;					// The collocate must not be merged with the base
?Zr.dsynt=OK;  						// wait for Z to be lexicalized
  ]
  rightside = [
rc:?Zr {				// agent
  <=> ?Zl
   lf::(?F.name).(gp).(X1)-> ?Wr { 
    <=> ?Wl <=> ?Ul			 // Ai + causative + Phase
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Phase_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Ul{				//phase
    sem=Incep|Fin|Cont|Prox|Prepar
    l:1->l:?Xl{}			//base   
  }
}
l:?Xl{				//base
  l:?r->?Zl {}			//actant	
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+?Ul.sem+"Oper"+?r or ?F.name="A3"+?Wl.sem+?Ul.sem+"Func"+?r;	
not ?F.merged=yes;					// The collocate must not be merged with the base
?Zr.dsynt=OK;  			// wait for Z to be lexicalized
not (?Xl 1->?Yl or ?Xl 2->?Yl or ?Xl 3->?Yl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Zr {				// actant
  <=> ?Zl
   lf::(?F.name).(gp).(X1)-> ?Wr { 
    <=> ?Wl <=> ?Ul			 // Ai node + Caus + Phase
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Phase_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Ul{			//phase
    sem=Incep|Fin|Cont|Prox|Prepar
    l:1->l:?Xl{	}		//base
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Ul.sem+"Oper0" or ?F.name="A2"+?Wl.sem+?Ul.sem+"Func0";	
not ?Xr.dsynt=OK;				// not sure if we have to keep it
not (?Xl 1->?Yl or ?Xl 2->?Yl or ?Xl 3->?Yl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr { 
	<=> ?Wl <=> ?Ul 	// Ai node + Caus + Phase
      dlex=?F.value
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Phase_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Ul{				//phase
    sem=Incep|Fin|Cont|Prox|Prepar
    l:1->l:?Xl{				//base
      l:?r->?Zl {}			//actant	
    }
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A3"+?Wl.sem+?Ul.sem+"Oper"+?r or ?F.name="A2"+?Wl.sem+?Ul.sem+"Func"+?r;	
not ?Xr.dsynt=OK;				// not sure if we have to keep it
not (?Xl 1->?Yl or ?Xl 2->?Yl or ?Xl 3->?Yl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{
	<=> ?Wl <=> ?Ul 	// Ai node + Caus + Phase
      dlex=?F.value
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Zr{   	// actant
          <=> ?Zl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_causX_Phase_Vsupp_cause : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:1-> ?Yl {}				//causative
  l:2->l:?Ul{				//phase
    sem=Incep|Fin|Cont|Prox|Prepar
    l:1->l:?Xl{	}			//base   
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+?Ul.sem+"Oper0" or ?F.name="A1"+?Wl.sem+?Ul.sem+"Func0";	
not ?F.merged=yes;					// The collocate must not be merged with the base
?Yr.dsynt=OK;  						// wait for Y to be lexicalized
not (?Xl 1->?Yl or ?Xl 2->?Yl or ?Xl 3->?Yl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Yr {				// agent
  <=> ?Yl
   lf::(?F.name).(gp).(X1)-> ?Wr { 
    <=> ?Wl <=> ?Ul			// Ai node + Caus + Phase
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
/*Needs debugging*/
Sem<=>DSynt disabled Ai_causX_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{		//base
    l:?r-> ?Yl {} 	
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A3"+?Wl.sem+"Func"+?r;
?F.name="A2"+?Wl.sem+"Oper"+?r;
//?F.name="A3"+?Wl.sem+"Func"+?r or "A2"+?Wl.sem+"Oper"+?r;
//?F.name="A2CausOper1";
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for U to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
//?Zr.dpos=A;
  ]
  rightside = [
rc:?Yr {				// rth actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  
    <=> ?Wl				// Ai + causative
    dlex=?F.value
    //dpos=lf::(?F.name).(dpos)
    dpos=A
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
/*Needs debugging*/
Sem<=>DSynt disabled Ai_causX_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{}		//base
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A2"+?Wl.sem+"Func0" or "A3"+?Wl.sem+"Oper0";
//?F.name="A3"+?Wl.sem+"Oper0";
not ?Xr.dsynt=OK;				// not sure if we have to keep it
not ?Xr.dpos=V;
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr { <=> ?Wl  // Ai node
      dlex=?F.value
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
/*Needs debugging*/
Sem<=>DSynt disabled Ai_causX_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{		//base
    l:?r-> ?Yl {} 	
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A2"+?Wl.sem+"Func"+?r or "A3"+?Wl.sem+"Oper"+?r;
?F.name="A3"+?Wl.sem+"Oper"+?r;
not ?Xr.dsynt=OK;				// not sure if we have to keep it
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{ <=> ?Wl  // Ai node
      dlex=?F.value
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   		// actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]
/*Needs debugging*/
Sem<=>DSynt disabled Ai_causX_Vsupp_cause : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Caus|Liqu|Perm
  l:2->l:?Xl{}		//base
  l:1-> ?Zl {}		// agent
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
//?F.name="A1"+?Wl.sem+"Func0" or "A1"+?Wl.sem+"Oper0";	
?F.name="A1"+?Wl.sem+"Oper0";	
not ?F.merged=yes;				// The collocate must not be merged with the base
//not ?Xr.dsynt=OK;				// not sure if we have to keep it
?Zr.dsynt=OK;  					// wait for Y to be lexicalized
not (?Xl 1->?Zl or ?Xl 2->?Zl or ?Xl 3->?Zl);	// makes sure the agent is not an actant of the base
  ]
  rightside = [
rc:?Zr {				// agent
  <=> ?Zl
   lf::(?F.name).(gp).(X1)-> ?Wr { 
    <=> ?Wl			 // Ai + causative
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   	// base
          <=> ?Xl 
         dlex=?L 
         dpos=lexicon::(?L).(dpos)
         dsynt=OK	
         }
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsupp_actant : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Xl{		//base
    l:?r-> ?Yl {}	//actant
  }
}
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+"Oper"+?r or ?F.name="A2"+?Wl.sem+"Func"+?r;	
?Yr.dpos=N;			// actant must be a noun
?Yr.dsynt=OK;  			// wait for Y to be lexicalized
not ?Xr.dsynt=OK;  		// Base must not be lexicalized
  ]
  rightside = [
rc:?Yr {				// ith actant
  <=> ?Yl
  lf::(?F.name).(gp).(?r)-> ?Zr{  <=> ?Wl		// Ai node
    dlex=?F.value
    dpos=lf::(?F.name).(dpos)
    dsynt=OK
    lf=?F.name
    base=?L
    lf::(?F.name).(gp).(L)-> ?Xr{   
      <=> ?Xl  				// base lexicalisation
      dlex=?L
      dpos=lexicon::(?L).(dpos)   
      dsynt=OK
     }
   }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsupp_base_0 : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Xl{}		//base
}  
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+"Func0" or ?F.name="A2"+?Wl.sem+"Oper0";	
not ?Xr.dsynt=OK;					// not sure if we have to keep it
not ?S 1->?Ul and (?S.sem="Caus" or 
?S.sem="Liqu" or
?S.sem="Perm");
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Yr{  <=> ?Wl   // Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
  }
}
  ]
  correspondence = [

  ]
]
Sem<=>DSynt disabled Ai_phase_Vsupp_base_i : Ai_Vsupp
[
  leftside = [
l:?Wl {
  sem=Prox|Incep|Cont|Fin|Prepar|Non
  l:1->l:?Xl{		//base
    l:?r-> ?Yl {} 	
  }		
}  
?L <- semanticon::(?Xl.sem).(lex)   
?F <- lexicon::(?L).(lf)
  ]
  conditions = [
?F.name="A1"+?Wl.sem+"Func"+?r or ?F.name="A2"+?Wl.sem+"Oper"+?r;	
not ?Xr.dsynt=OK;					// not sure if we have to keep it
not ?S 1->?Ul and (?S.sem="Caus" or 
?S.sem="Liqu" or
?S.sem="Perm");
  ]
  rightside = [
rc:?Xr {			// base
  <=> ?Xl
   dlex=?L 
   dpos=lexicon::(?L).(dpos)
   dsynt=OK
   lf::(?F.name).(gp).(L)-> ?Wr{  <=> ?Wl   // Ai node
      dlex=?F.value
      dpos=lf::(?F.name).(dpos)
      dsynt=OK
      lf=?F.name
      base=?L
      lf::(?F.name).(gp).(?r)-> ?Yr{   		// actant
          <=> ?Yl  		
         }
  }
}
  ]
  correspondence = [

  ]
]